import fs from 'fs'
import path from 'path'
import matter from 'gray-matter'
import remark from 'remark'
import html from 'remark-html'

// Get the content directory, which will be used in all the functions of this library:
// - Since Next.js compiles the code into a separate directory you can't use __dirname as the path it will return will be different from the pages directory.
// - Instead you can use process.cwd() which gives you the directory where Next.js is being executed. 
const blogDirectory = path.join(process.cwd(), 'content/blog')

// This function returns a list of blog posts in the format "lang/post_id.md":
function getAllPostFileNames(directoryPath, filesList = []) {
  const files = fs.readdirSync(directoryPath)

  files.forEach((file) => {
    if (fs.statSync(`${directoryPath}/${file}`).isDirectory()) {
      filesList = getAllPostFileNames(`${directoryPath}/${file}`, filesList)
    } else {
      filesList.push(path.join(path.basename(directoryPath), "/", file))
    }
  })

  // Filter to include only * .md files (and avoid files like .DS_Stores):
  const filteredList = filesList.filter((file) => file.includes(".md"))
  return filteredList
}

// This function creates the data for the blog index:
// - It will be used by the getStaticProps of the blog index and the tag index (/blog.js & /blog/tag/[id].js).
// - tagID will exist only for the tag index.
export function getSortedBlogData(currentLocale, tagID) {
  const fileNames = getAllPostFileNames(blogDirectory)

  // Create the data for each post iterating through the list generated by getAllPostFileNames:
  const blogData = fileNames.map(fileName => {
    // Remove ".md" from file name to get ID:
    const id = fileName.split("/")[1].replace(/\.md$/, "")
    // Get the locale:
    const locale = fileName.split("/")[0]
    // Read markdown file as string:
    const fullPath = path.join(blogDirectory, fileName)
    const fileContents = fs.readFileSync(fullPath, 'utf8')
    // Use gray-matter to parse the post metadata section:
    const matterResult = matter(fileContents)
    // Combine the metadata with the ID and the locale:
    return {
      id,
      locale,
      ...matterResult.data
    }
  })

  // Filter by the current language:
  const blogDataFilteredByLocale = blogData.filter((post) => post.locale === currentLocale)
  let blogDataFinal = blogDataFilteredByLocale

  // Filter by the tag, if we are creating the data for a tag index:
  let tagValue
  if (tagID) {
    // First, let's create a new blog posts array with a simplified tags array called tagsIDs, to make the filter easier:
    var blogDataPreFilteredByTag = [];
    for (var i = 0; i < blogDataFilteredByLocale.length; i++) {
      blogDataPreFilteredByTag.push({
          'id': blogDataFilteredByLocale[i].id,
          'locale': blogDataFilteredByLocale[i].locale,
          'title': blogDataFilteredByLocale[i].title,
          'date': blogDataFilteredByLocale[i].date,
          'tags': blogDataFilteredByLocale[i].tags,
          'tagsIDs': blogDataFilteredByLocale[i].tags.map(({id}) => id),
          'indexImage': blogDataFilteredByLocale[i].indexImage,          
      });
    }
    // Now we filter by the tag...
    blogDataFinal = blogDataPreFilteredByTag.filter((post) => {
      return (post.tagsIDs.indexOf(tagID) >= 0);
    });
    // ... and take the opportunity to get the tag (the value, not the ID) to show on the page...
    const tag = blogDataFinal[0].tags.filter( (tag) => tag.id === tagID )
    tagValue = tag[0].tag
    // ... and then, finally, delete the tagsIDs array, since it's not necessary anymore:
    blogDataFinal.forEach(function(post){ delete post.tagsIDs });
  }
  
  // Sort the projects by position and send with the tag:
  // - The tag will be null, if we are sending the data to the blog index (/blog.js);
  // - It will have value only for the tag index (/blog/tag/[id].js).
  return {sortedBlogData: blogDataFinal.sort((a, b) => {
            if (a.date < b.date) {
              return 1
            } else {
              return -1
            }
          }),
          tag: tagValue
        }

}

// This function creates a list of blog posts IDs and locales, which will be used for the Dynamic Routes:
// - It will be used by the getStaticPaths of the post (/blog/[id].js).
// - For dynamic getStaticProps pages, any locale variants of the page that is desired to be prerendered needs to be returned from getStaticPaths. 
// - Along with the params object that can be returned for the paths, you can also return a locale field specifying which locale you want to render.
// - The format should be like this:
// - [
// -   { params: { id: 'postId' }, locale: 'lang' },
// -   { params: { id: 'postId' }, locale: 'lang' },
// - ]
export function getAllPostIds() {
  const fileNames = getAllPostFileNames(blogDirectory)
 
  // Create the paths iterating through the list generated by getAllPostFileNames:
  // - Combine the IDs with each locale.
  return fileNames.map((fileName) => ({
    params: { id: fileName.split("/")[1].replace(/\.md$/, ""), },
    locale: fileName.split("/")[0],
  }))  

}

// This function creates a list of blog tags IDs and locales, which will be used for the Dynamic Routes:
// - It will be used by the getStaticPaths of the tag index (/blog/tag/[id].js), which is a page that shows the posts associated with this tag.
// - For dynamic getStaticProps pages, any locale variants of the page that is desired to be prerendered needs to be returned from getStaticPaths. 
// - Along with the params object that can be returned for the paths, you can also return a locale field specifying which locale you want to render.
// - The format should be like this:
// - [
// -   { params: { id: 'tagId' }, locale: 'lang' },
// -   { params: { id: 'tagId' }, locale: 'lang' },
// - ]
export function getAllTagIds() {
  const fileNames = getAllPostFileNames(blogDirectory)

  // Create the paths iterating through the list generated by getAllPostFileNames:
  const blogTags = fileNames.map(fileName => {
    // Remove ".md" from file name to get ID:
    const id = fileName.split("/")[1].replace(/\.md$/, "")
    // Get the locale:
    const locale = fileName.split("/")[0]
    // Read markdown file as string:
    const fullPath = path.join(blogDirectory, fileName)
    const fileContents = fs.readFileSync(fullPath, 'utf8')
    // Use gray-matter to parse the post metadata section:
    const matterResult = matter(fileContents)
    // Combine the tags with each locale:
    return matterResult.data.tags.map((currentTag) => ({
        params: { id: currentTag.id },
        locale: locale,
    }))
  })
  // Creates a new array with all sub-array elements concatenated into it recursively (because some posts have more than one tag):
  const tags = blogTags.flat()
  // Eliminate repeated tags (since they can be in many posts):
  const uniqueTags = tags.filter((tag, index, self) =>
    index === self.findIndex((t) => (
      t.params.id === tag.params.id && t.params.tag === tag.params.tag && t.locale === tag.locale
    ))
  )
  return uniqueTags
}

// This function creates the data of a specific post:
// - It will be used by the getStaticProps of the post (/blog/[id].js):
export async function getPostData(locale_PostId) {

  // Get the content from the post file:
  const fullPath = path.join(blogDirectory, `${locale_PostId}.md`)
  const fileContents = fs.readFileSync(fullPath, 'utf8')

  // Use gray-matter to parse the post metadata section:
  const matterResult = matter(fileContents)

  // Use remark to convert markdown into HTML string:
  const processedContent = await remark()
    .use(html)
    .process(matterResult.content)
  const contentHtml = processedContent.toString()
  
  // Combine the metadata with the contentHtml and the locale_ProjectId:
  return {
    locale_PostId,
	  contentHtml,
    ...matterResult.data
  }
}

// This function generates the necessary XML to describe the RSS feed:
// - Official specification: https://validator.w3.org/feed/docs/rss2.html#requiredChannelElements
export const generateBlogRss = (blogData, rssDescription, locale) => `
  <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
      <title>Dr Natalia Vale Asari - Blog (${locale})</title>
      <link>https://natalia-vale-asari-v2.vercel.app/${locale}/blog</link>
      <description>${rssDescription}</description>
      <language>${locale}</language>
      <lastBuildDate>${new Date(blogData[0].date).toUTCString()}</lastBuildDate>
      <atom:link href="https://natalia-vale-asari-v2.vercel.app/rss/blog-${locale}.xml" rel="self" type="application/rss+xml"/>
      ${blogData.map(generateBlogRssItem).join('')}
    </channel>
  </rss>
`

// This function generates the necessary XML to describe the itens of the RSS feed:
// - Official specification: https://validator.w3.org/feed/docs/rss2.html#hrelementsOfLtitemgt
const generateBlogRssItem = (post) => `
  <item>
     <guid isPermaLink="true">https://natalia-vale-asari-v2.vercel.app/${post.locale}/blog/${post.id}</guid>
     <title>${post.title}</title>
     <link>https://natalia-vale-asari-v2.vercel.app/${post.locale}/blog/${post.id}</link>
     <description>${post.summary}</description>
     <pubDate>${new Date(post.date).toUTCString()}</pubDate>
  </item>
`