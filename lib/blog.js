import fs from 'fs'
import path from 'path'
import matter from 'gray-matter'
import remark from 'remark'
import html from 'remark-html'
import * as translationsLibrary from "./translationsLibrary.js"

// Get the content directory:
// - Since Next.js compiles the code into a separate directory you can't use __dirname as the path it will return will be different from the pages directory.
// - Instead you can use process.cwd() which gives you the directory where Next.js is being executed. 
const blogDirectory = path.join(process.cwd(), 'content/blog')

// The number of posts per page:
const postsCountPerPage = '10'

// ==============================
// This function calculates the number of pages according to a given number of posts and the postsCountPerPage declared above:
function calculatePages(postsCount) {
  return Math.ceil(postsCount / postsCountPerPage)
}

// ==============================
// This function returns a list of blog posts in the format "lang/post_id.md":
function getAllPostFileNames(directoryPath, filesList = []) {
  const files = fs.readdirSync(directoryPath)

  files.forEach((file) => {
    if (fs.statSync(`${directoryPath}/${file}`).isDirectory()) {
      filesList = getAllPostFileNames(`${directoryPath}/${file}`, filesList)
    } else {
      filesList.push(path.join(path.basename(directoryPath), "/", file))
    }
  })

  // Filter to include only * .md files (and avoid files like .DS_Stores):
  const filteredList = filesList.filter((file) => file.includes(".md"))
  return filteredList
}

// ==============================
// This function creates the paths for the posts: a list with all the combinations of posts IDs and locales, which will be used for the paths of the Dynamic Routes:
// - It will be used by the getStaticPaths of the post (/blog/[id].js).
// - For dynamic getStaticProps pages, any locale variants of the page that is desired to be prerendered needs to be returned from getStaticPaths. 
// - Along with the params object that can be returned for the paths, you can also return a locale field specifying which locale you want to render.
// - The format should be like this:
// - [
// -   { params: { id: 'postId' }, locale: 'lang' },
// -   { params: { id: 'postId' }, locale: 'lang' },
// - ]
export function getAllPostIds() {
  const fileNames = getAllPostFileNames(blogDirectory)
 
  // Create the paths iterating through the list generated by getAllPostFileNames:
  // - Combine the IDs with each locale.
  return fileNames.map((fileName) => ({
    params: { id: fileName.split("/")[1].replace(/\.md$/, ""), },
    locale: fileName.split("/")[0],
  }))  
}

// ==============================
// This function creates the paths for the blog index: a list with all the combinations of tags, page numbers and locales, which will be used for the paths of the Dynamic Routes:
// - It will be used by the getStaticPaths of the blog index (/blog/show/[tagId]/[page].js).
// â€” The tags are used to filter posts by tag; the pages for pagination.
// - For dynamic getStaticProps pages, any locale variants of the page that is desired to be prerendered needs to be returned from getStaticPaths. 
// - Along with the params object that can be returned for the paths, you can also return a locale field specifying which locale you want to render.
// - The format should be like this:
// - [
// -   { params: { tagId: 'tagId', page: 'page' }, locale: 'lang' },
// -   { params: { tagId: 'tagId', page: 'page' }, locale: 'lang' },
// - ]
export function getTagsAndLocalesAndPagesNumbers() {
  const fileNames = getAllPostFileNames(blogDirectory)

  // Let's start iterating through the list generated by getAllPostFileNames and create a list of tags (including repetitions, which means different posts using the same tag) and the locales of these posts:
  const tagsAndLocales = fileNames.map(fileName => {
    // Remove ".md" from file name to get ID:
    const id = fileName.split("/")[1].replace(/\.md$/, "")
    // Get the locale:
    const locale = fileName.split("/")[0]
    // Read markdown file as string:
    const fullPath = path.join(blogDirectory, fileName)
    const fileContents = fs.readFileSync(fullPath, 'utf8')
    // Use gray-matter to parse the post metadata section:
    const matterResult = matter(fileContents)
    // Combine the tags with each locale:
    return matterResult.data.tags.map((currentTag) => ({
        params: { tagId: currentTag.id },
        locale: locale,
    }))
  }).flat()
  // Now we group this list by tag and locale to discover the number of posts for each pair:
  const tagsAndLocalesAndPostsCount = [...tagsAndLocales.reduce((r, o) => {
    const key = o.params.tagId + " / " + o.locale
    const item = r.get(key) || Object.assign({}, o, {
      postsCount: 0
    });
    item.postsCount++
    return r.set(key, item);
  }, new Map).values()];
  // And then, we create a new list converting the number of posts in number of pages:
  const tagsAndLocalesAndPagesCount = tagsAndLocalesAndPostsCount.map(item => ({ ...item, pages: calculatePages(item.postsCount) }))
  // Now we have to create a new list with every possible page for every pair of tag and locale. Let's create a function that will do it for every line on our tagsAndLocalesAndPagesCount:
  function createPages(item) {
    var path = []
    for (var i = 1; i <= item.pages; i++) {
       path.push({ params: { tagId: item.params.tagId, page: i.toString() }, locale: item.locale })
    }
    return path 
  }
  // Then we map our tagsAndLocalesAndPagesCount with this function, to create the paths:
  var tagsAndLocalesAndPagesNumbers = [] 
  tagsAndLocalesAndPagesNumbers = tagsAndLocalesAndPagesCount.map((item) => createPages(item)).flat()
  // Finally, let's create the paths for the "all" tag, that will be used to show all the posts. We need to know the sum of posts per locale:
  const postsPerLocale = fileNames.map(fileName => {
    const locale = fileName.split("/")[0]
    return locale
  })
  const postsCountPerLocale = postsPerLocale.reduce((total, value) => {
     total[value] = (total[value] || 0) + 1;
     return total;
  }, {});
  // Then we calculate the number of pages for each locale:
  const pagesCountPerLocale = {}
  Object.keys(postsCountPerLocale).map(function(key, index) {
    pagesCountPerLocale[key] = calculatePages(postsCountPerLocale[key])
  });  
  // Finally, we create a function that will iterate on each item of pagesCountForLocale and generate the paths for the "all" tag:  
  function createPagesForTheAllTag(pagesCountForLocale) {
    const locale = Object.keys(pagesCountForLocale)[0]
    const pages = pagesCountForLocale[locale]
    var path = []
    for (var i = 1; i <= pages; i++) {
       path.push({ params: { tagId: 'all', page: i.toString() }, locale: locale })
    }
    return path
  }
  // Then we convert the object pagesCountPerLocale into an array...
  const pagesCountPerLocaleArray = Object.entries(pagesCountPerLocale).map(([key, value]) => ({ [key]: value }));
  // ... and map this array with the function, to create the paths for the "all" tag:
  const TagAllAndLocalesAndPageNumbers = pagesCountPerLocaleArray.map((item) => createPagesForTheAllTag(item)).flat()
  // Now we merge the paths for the "all" tag into our tagsAndLocalesAndPagesNumbers and it's done:
  tagsAndLocalesAndPagesNumbers = tagsAndLocalesAndPagesNumbers.concat(TagAllAndLocalesAndPageNumbers)
  return tagsAndLocalesAndPagesNumbers
}

// ==============================
// This function creates the data of a specific post:
// - It will be used by the getStaticProps of the post (/blog/[id].js):
export async function getPostData(locale_PostId) {

  // Get the content from the post file:
  const fullPath = path.join(blogDirectory, `${locale_PostId}.md`)
  const fileContents = fs.readFileSync(fullPath, 'utf8')

  // Use gray-matter to parse the post metadata section:
  const matterResult = matter(fileContents)

  // Use remark to convert markdown into HTML string:
  const processedContent = await remark()
    .use(html)
    .process(matterResult.content)
  const contentHtml = processedContent.toString()
  
  // Combine the metadata with the contentHtml and the locale_ProjectId:
  return {
    locale_PostId,
	  contentHtml,
    ...matterResult.data
  }
}

// ==============================
// This function creates the data for the blog index:
// - It will be used by the getStaticProps of the blog index (/blog/show/[tagId]/[page].js).
// - tagID will exist only for the tag index.
export function getBlogData(currentLocale, tagID, page) {
  const fileNames = getAllPostFileNames(blogDirectory)

  // Create the data for each post iterating through the list generated by getAllPostFileNames:
  const blogData = fileNames.map(fileName => {
    // Remove ".md" from file name to get ID:
    const id = fileName.split("/")[1].replace(/\.md$/, "")
    // Get the locale:
    const locale = fileName.split("/")[0]
    // Read markdown file as string:
    const fullPath = path.join(blogDirectory, fileName)
    const fileContents = fs.readFileSync(fullPath, 'utf8')
    // Use gray-matter to parse the post metadata section:
    const matterResult = matter(fileContents)
    // Combine the metadata with the ID and the locale:
    return {
      id,
      locale,
      ...matterResult.data
    }
  })

  // Filter by the current locale:
  const blogDataFilteredByLocale = blogData.filter((post) => post.locale === currentLocale)
  let blogDataFinal = blogDataFilteredByLocale

  // Filter by the tag, if we are creating the data for a tag index:
  let indexTag = {}
  if (tagID !== 'all') {
    // First, let's create a new blog posts array with a simplified tags array called tagsIDs, to make the filter easier:
    var blogDataPreFilteredByTag = [];
    for (var i = 0; i < blogDataFilteredByLocale.length; i++) {
      blogDataPreFilteredByTag.push({
          'id': blogDataFilteredByLocale[i].id,
          'locale': blogDataFilteredByLocale[i].locale,
          'title': blogDataFilteredByLocale[i].title,
          'date': blogDataFilteredByLocale[i].date,
          'tags': blogDataFilteredByLocale[i].tags,
          'tagsIDs': blogDataFilteredByLocale[i].tags.map(({id}) => id),
          'indexImage': blogDataFilteredByLocale[i].indexImage,          
      });
    }
    // Now we filter by the tag...
    blogDataFinal = blogDataPreFilteredByTag.filter((post) => {
      return (post.tagsIDs.indexOf(tagID) >= 0);
    });
    // ... and take the opportunity to get the tag being used in the index...
    const tag = blogDataFinal[0].tags.filter( (tag) => tag.id === tagID )
    indexTag.tag = tag[0].tag
    indexTag.id = tag[0].id
    // ... and then, finally, delete the tagsIDs array, since it's not necessary anymore:
    blogDataFinal.forEach(function(post){ delete post.tagsIDs });
  } else {
    indexTag.tag = 'all'
    indexTag.id = 'all'
  }
  
  // Sort the projects by position:
  const sortedBlogData = blogDataFinal.sort((a, b) => {
            if (a.date < b.date) {
              return 1
            } else {
              return -1
            }
          })

  // Let's take the opportunity to generate the RSS feed file:
  // - We do it only for the "all" tag build, because the RSS is for all the posts regardless of their tags, and also only for the page "1", to avoid rewriting the file for every page build process (it will use sortedBlogData, anyway, which is not yet paginated).
  if ((tagID == 'all') && (page == '1')) {
    const translations = translationsLibrary[currentLocale].blogIndex
    const rss = generateBlogRss(sortedBlogData, translations.rssDescription, currentLocale)
    fs.writeFileSync('public/rss/blog-'.concat(currentLocale, '.xml'), rss)
  }

  // Create the pagination meta-info:
  const postsCount = blogDataFinal.length
  const pagesCount = calculatePages(postsCount)
  const pagination = {
          postsCountPerPage: postsCountPerPage,
          postsCount: postsCount,
          pagesCount: pagesCount
      }

  // Get only the posts for the current page:
  // - For the logic bellow, let's not forget that the counter starts with 0, because the keys in arrays in JS start with 0.
  var sortedBlogDataPerPage = []
  for (var i = (postsCountPerPage*(page-1)); i <= ((page*postsCountPerPage)-1); i++) {
   // If the counter is equal to the postsCount (that is, we passed the last post, which is postsCount-1) then we jump out of the loop:
   if (i == (postsCount)) { break }
   // If not, we continue adding posts:
   sortedBlogDataPerPage.push(sortedBlogData[i])
  }
  
  // Send the data with the tag and the pagination meta-info:
  return {sortedBlogDataPerPage,
          indexTag: indexTag,
          pagination,
          currentPage: page
        }
}

// ==============================
// This function generates the necessary XML to describe the RSS feed:
// - Official specification: https://validator.w3.org/feed/docs/rss2.html#requiredChannelElements
export const generateBlogRss = (blogData, rssDescription, locale) => `
  <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
      <title>Dr Natalia Vale Asari - Blog (${locale})</title>
      <link>https://www.nataliavaleasari.net/${locale}/blog</link>
      <description>${rssDescription}</description>
      <language>${locale}</language>
      <lastBuildDate>${new Date(blogData[0].date).toUTCString()}</lastBuildDate>
      <atom:link href="https://www.nataliavaleasari.net/rss/blog-${locale}.xml" rel="self" type="application/rss+xml"/>
      ${blogData.map(generateBlogRssItem).join('')}
    </channel>
  </rss>
`
// ==============================
// This function generates the necessary XML to describe the itens of the RSS feed:
// - Official specification: https://validator.w3.org/feed/docs/rss2.html#hrelementsOfLtitemgt
const generateBlogRssItem = (post) => `
  <item>
     <guid isPermaLink="true">https://www.nataliavaleasari.net/${post.locale}/blog/${post.id}</guid>
     <title>${post.title}</title>
     <link>https://www.nataliavaleasari.net/${post.locale}/blog/${post.id}</link>
     <description>${post.summary}</description>
     <pubDate>${new Date(post.date).toUTCString()}</pubDate>
  </item>
`
